For customised-scheduling (Shortest-Process-First), it stores the process into a min-heap, which sorts the process based their job-time; process with shortest job-time is executed firstly. It performs better than first-come-first-served and round-robin algorithms in most cases. Since the process with shortest job-time gets executed early, the average waiting-time for each process decreases. The overhead of long process is decreased by its long job-time and relatively short waiting time. However, this strategy cannot work in situation when short processâ€™s execution may depend on long process. In this situation, the long process has to be executed before short process. 

For customised-memory-management, it changes page replacement policy based on virtual-memory management. It uses a combination of Least-Recently-Used policy and Least-Frequently-Used policy. Page whose last-access time is early and number of times used is low will be swapped for new processes. It is similar to virtual-memory-management in most cases since it is derived from virtual-memory-management, but it performs better when the least-recently process is likely to be executed in near future and it balances usage of memory based on used times. It performs worse than swapping-x when job-time of process is short but requires a lot memory, which suffers time penalty.
